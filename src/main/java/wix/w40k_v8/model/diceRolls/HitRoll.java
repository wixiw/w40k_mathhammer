/**
 * 
 */
package wix.w40k_v8.model.diceRolls;

/**
 * @author wix This class represent a hit roll sequence (either for cloce combat
 *         or distance)
 */
public class HitRoll {

    /** Number of attacks */
    protected double attacks;

    /** Attacking model hit skill */
    protected Skill skill;

    /** Hit modifier */
    protected int mod;

    /** minimal score on a dice to create additional attacks */
    protected int explAttValue;

    /** number of additional attacks generated on each "explAttValue" success */
    protected int explAttCount;

    /** minimal score on dice to create additional hits */
    protected int extraHitsValue;

    /** number of additional hit created on each "extraHitsValue" success */
    protected int extraHitsCount;

    /**
     * Configure the number of attacks (dices) in the roll
     * Compulsory call before roll()
     * @param attacksCount
     *            shall be positive of throw IllegalArgumentException
     */
    public void setAttacks(double attacksCount) {
	if (attacksCount < 0)
	    throw new IllegalArgumentException();
	attacks = attacksCount;
    }

    /**
     * Set the skill of the model making the roll
     * Compulsory call before roll()
     * @param s
     */
    public void setSkill(Skill s) {
	skill = s;
    }

    /**
     * Dice result modifier (+1, -1, ...)
     * 
     * @param modifier
     */
    public void setModifier(int modifier) {
	mod = modifier;
    }

    /**
     * Extra attacks generated for each dice face (they will need to be rolled
     * again)
     * 
     * @param minFace
     *            minimal value to reach with the dice (equal or more), shall be
     *            stricly positive or throw IllegalArgumentException
     * @param extraAttacks
     *            number of new attacks generated by successful results, shall
     *            be stricly positive or throw IllegalArgumentException
     */
    public void setAdditionnalAttacks(int minFace, int extraAttacks) {
	if (minFace <= 0 || extraAttacks <= 0) {
	    throw new IllegalArgumentException();
	}

	explAttValue = minFace;
	explAttCount = extraAttacks;
    }

    /**
     * Extra auto-hits generated for each dice face (hence not rolled, cf tesla)
     * 
     * @param minFace
     *            minimal value to reach with the dice (equal or more)
     * @param extraHits
     *            number of new attacks generated by successful results
     */
    public void setAdditionnalHits(int minFace, int hits) {
	assert 0 < minFace;
	assert 0 < hits;

	extraHitsValue = minFace;
	extraHitsCount = hits;
    }

    /**
     * Roll the dices
     * 
     * @return the number of successfull hits
     */
    public double roll() {
	// Check that minimal configuration has been done
	if (attacks == 0 || skill.getValue() == 0)
	    throw new IllegalArgumentException();

	// Roll dices a first time
	DiceResults dices = DiceResults.statsRollD6(attacks);

	// If allowed, reroll failed dices and add them to first Roll
	_rerollDices(dices);

	// If allowed create additional attacks
	if (explAttCount != 0) {
	    // Roll extra attacks
	    double extraAttackCount = explAttCount * dices.countSuccess(explAttValue - mod);
	    DiceResults extraAttacks = DiceResults.statsRollD6(extraAttackCount);

	    // If allowed, reroll additional attacks failed dices
	    _rerollDices(extraAttacks);
	    // Add extra attacks to first roll
	    dices.addRolls(extraAttacks);
	}

	// Count success with modifier
	double success = dices.countSuccess(skill.getValue() - mod);

	// If allowed, create additional hits (like tesla)
	if (extraHitsCount != 0)
	    success += extraHitsCount * dices.countSuccess(extraHitsValue - mod);

	return success;
    }

    protected void _rerollDices(DiceResults dices) {
	// If allowed, reroll additional attacks failed dices
	switch (skill.getRerolls()) {

	case Ones:
	    dices.rerollDicesBelow(2);
	    break;

	case MayAll:
	    // If reroll capacity is optional and under a hit bonus
	    // we can keep dices that would failed before modifier but would be
	    // ok with it.
	    if (0 < mod)
		dices.rerollDicesBelow(skill.getValue() - mod);
	    else
		dices.rerollDicesBelow(skill.getValue());
	    break;

	case MustAll:
	    dices.rerollDicesBelow(skill.getValue());
	    break;

	case Nothing:
	    break;

	default:
	    throw new UnsupportedOperationException();
	}
    }
}
