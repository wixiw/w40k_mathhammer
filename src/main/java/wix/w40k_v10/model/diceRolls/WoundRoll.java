/**
 * 
 */
package wix.w40k_v10.model.diceRolls;

import sun.reflect.generics.reflectiveObjects.NotImplementedException;
import java.lang.Math;

/**
 * @author wix This class represent a hit roll sequence (either for close combat
 *         or distance shooting)
 */
public class WoundRoll {
    
    public static class Wounds{
	public double normal;
	public double mortals;
    }

    /** Number of hits in the previous roll */
    protected double hits;

    /**
     * minimal score on dice to wound, computed from strength and toughness
     * comparaison
     */
    protected int woundValue;

    /**
     * An enumeration representing the wound roll reroll capacities, see \see
     * Skill
     */
    protected DiceRoll.RerollType woundReroll;

    /** Wound modifier */
    protected int mod;

    /** poisonned attacks never wound worse than this value */
    protected int poisonValue;

    /** minimal score on dice to create additional hits */
    protected int extraMWValue;

    /** number of additional hit created on each "extraHitsValue" success */
    protected int extraMWCount;

    /**
     * is true if the extra mortal wound replace the wound roll, false if it is
     * generated in addition to the wound
     */
    protected boolean extraMWReplaceWound;

    /**
     * Configure the number of hits (dices) in the roll
     * 
     * @param hitsCount
     *            shall be stricly positive of throw IllegalArgumentException
     */
    public void setHitCount(double hitsCount) {
	if (hitsCount <= 0)
	    throw new IllegalArgumentException();
	hits = hitsCount;
    }

    /**
     * Setup the 2 models in combat
     * 
     * @param attS
     *            the strength charateristic of the attacker, shall be positive
     *            and non null, else throw IllegalArgumentException
     * @param defT
     *            the toughness of the defenser, shall be positive and non null,
     *            else throw IllegalArgumentException
     * @param reroll
     *            an enumeration of reroll capacities of the attacker see \see Skill
     * @return the minimal wound dice result to make a success
     */
    public int setModels(int attS, int defT, DiceRoll.RerollType reroll) {
	if (attS <= 0 || defT <= 0)
	    throw new IllegalArgumentException();

	woundReroll = reroll;

	// equality case
	woundValue = 4;

	if (defT < attS)
	    woundValue = 3;

	if (2 * defT <= attS)
	    woundValue = 2;

	if (attS < defT)
	    woundValue = 5;

	if (2 * attS <= defT)
	    woundValue = 6;

	return woundValue;
    }

    /**
     * Setup the 2 models in combat (no wound reroll)
     * 
     * @param attS
     *            the strength charateristic of the attacker,,shall be positive
     *            and non null, else throw IllegalArgumentException
     * @param defT
     *            the toughness of the defenser, shall be positive and non null,
     *            else throw IllegalArgumentException
     * @return the minimal wound dice result to make a success
     */
    public int setModels(int attS, int defT) {
	return setModels(attS, defT, DiceRoll.RerollType.Nothing);
    }

    /**
     * Dice result modifier (+1, -1, ...)
     * 
     * @param modifier
     */
    public void setModifier(int modifier) {
	mod = modifier;
    }

    /**
     * Configure the attacking weapon to be poisoned (i.e.) never wound worst
     * than the parameter value 
     * 
     * @param poisonRoll
     *            : the worst wound roll that end in a wound
     */
    public void setPoison(int poisonRoll) {
	poisonValue = poisonRoll;
    }

    /**
     * Extra mortal wounds generated for some dice result
     * 
     * @param minRoll
     *            minimal value to reach with the dice (equal or more), shall be
     *            greather than 2, else throw IllegalArgumentException
     * @param mortals
     *            the number of mortal wound generated, shall be positive and
     *            non null, else throw IllegalArgumentException
     * @param replace
     *            set to true if the mortal wound is in place of the wound,
     *            false for in addition to the wound number of new attacks
     *            generated by successful results
     */
    public void setMortalWounds(int minRoll, int mortals, boolean replace) {
	if (minRoll <= 1 || mortals <= 0)
	    throw new IllegalArgumentException();

	extraMWValue = minRoll;
	extraMWCount = mortals;
	extraMWReplaceWound = replace;
    }

    /**
     * Roll the dices. setAttacks() and setModel() shall have been called
     * before, else it will throw IllegalArgumentException
     * 
     * @return the number of successful wounds (normal and mortals)
     */
    public Wounds roll() {
	Wounds result = new Wounds();
	
	// Check that minimal configuration has been done
	if (hits == 0 || woundValue == 0)
	    throw new IllegalArgumentException();

	//Take poison into account
	int woundSucess;
	if(poisonValue != 0)
	    woundSucess = poisonValue;
	else
	    woundSucess = woundValue - mod;
	    
	// Roll dices a first time
	DiceRoll dices = DiceRoll.statsRollD6(hits);

	//If allowed, reroll failed dices and add them to first Roll
	 _rerollDices(dices, woundSucess);
	
	//Count success
	result.normal = dices.countSuccess(woundSucess);
	
	//Count extral mortal wounds
	result.mortals =  extraMWCount*dices.countSuccess(extraMWValue - mod);
	if(extraMWReplaceWound)
	    result.normal -= result.mortals/extraMWCount;
	
	return result;
    }

    protected void _rerollDices(DiceRoll dices, int woundSuccess) {
	// If allowed, reroll additional attacks failed dices
	switch (woundReroll) {

	case Ones:
	    dices.rerollDicesStrictBelow(2);
	    break;

	case MayAll:
	    // If reroll capacity is optional and under a hit bonus
	    // we can keep dices that would failed before modifier but would be
	    // ok with it.
	    if (0 < mod)
		dices.rerollDicesStrictBelow(woundSuccess);
	    else
		if(poisonValue != 0)
		    dices.rerollDicesStrictBelow(Math.min(woundValue, poisonValue));
		else
		    dices.rerollDicesStrictBelow(woundValue);
	    break;

	case MustAll:
		if(poisonValue != 0)
		    dices.rerollDicesStrictBelow(Math.min(woundValue, poisonValue));
		else
		    dices.rerollDicesStrictBelow(woundValue);
	    break;

	case Nothing:
	    break;

	default:
	    throw new UnsupportedOperationException();
	}
    }
}
